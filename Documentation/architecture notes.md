# Client
## Source Code Structure
```
/Client
   | - /Components : All Blazor components rendering the UI
   | - /Pages : Blazor components with dedicated page Url
   | - /Scripts : Interop typescript source
   | - /Services : Services managing the actual data displayed by the UI
```
## State Management
The clients state is completely determined by its services, which maintain connection with the server and cache data available to the user. 
* The **ChatApiService** is responsible of managing the users session (enabling communication with the Api in the first place) and wrapping Http requests to the Api in a simplified interface for other services and components.
* The **ChatHubService** maintains connection to the SignalR hub and provides C# events for SignalR events
* The **ChatStateService** maintains all other state information known to the client and provides interfaces for manipulating this state.
    * Collections of Users and Channels known to the account.
    * Pending and active RTC calls.
    * Currently viewed channel.
    * Messages of the currently viewed channel (often a subset of all available messages, within a timewindow)

A common concept used is the Observable (defined in Client/Observable.cs). It is a simple helper object combining a state with an event which is invoked whenever the state changes. This helper class is utilised to keep the state services and the UI components in sync.

## User Interface

Chat and Call Interfaces are entirely separate (if a call is active, the ChatRoot component is replaced by the CallRoot component in the Root component).

Components can be split roughly into two types:
* Viewers which primarily just display data set via parameters and usually don't interface directly with services
* Controlling elements which display more complex information provided by the service interfaces by arranging other controlling elements and viewers

## JS Interop

Blazor WASM offers extremely limited access to the Browser Api (natively accessed via Javascript). The following features required Browser Api access to be implemented:
* Detect the message list scroll position via [IntersectionObserver Api](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)
* Scroll messages into view by scrolling their elements into view
* Everything WebRTC for peer 2 peer audio/video calls, see the [dedicated WebRTC notes file](./webrtc.md)

### Notes
* You are not guaranteed to get an error message in the browser console when an exception or Promise rejection occurs in Javascript code. To get feedback on calls to error prone Apis such as WebRTC, wrap your calls in a try catch logging errors to console manually when they occur.
* If your WASM project features a lot of JS code, consider the following
    * Build it in a JS native framework in the first place
    * Use Webpack to make your JS stuff a bit smaller

# Server
## Source Code Structure
```
/Server
   | - /AdminApi : REST Api Controllers for the Admin Api
   | - /Controllers : REST Api Controllers for the Client <-> Server Api
   | - /Hubs
          | - ChatHub : SignalR Hub Implementation
          | - HubManager : SignalR Helper Service to organise connections and watch them
                           (detect connection loss)
   | - /Models : Types used for accessing and validating data in the database backend
   | - /Pages : Autogenerated fallback page
   | - /Services : Various services organising and compartmentalising data access
```
## Database
### Entity Relation Diagram
![Entity Relation Diagram](./entity-relation-diagram.svg)

### Cosmos DB
Currently the sole database backend service implementation is Azure Cosmos DB. This has some implications on the design of other components:
* **Partition Keys**: Cosmos DB uses a partition key (a secondary non-unique identification component) which azure's servers use to scope queries to smaller sections of the database. 
    * For most tables these partition keys are just a hash of the primary key.
    * The message table is scoped by Channel Id as it allows scoping queries of messages constrained to a channel to be cheaper in RUs (and presumably also quicker).
* **Document Database**: CosmosDB is a document database, which means is able to store almost unstructured data in the form of Json documents. This option has been used to some extend, refer to the entity relation diagram
    * Rather than having a table describing media embeds these descriptions are part of the references instead, forming an object
    * The Form and Form Response tables store generic json in one of their fields
* **Queries**: CosmosDBs SQL dialect ([Transact SQL](https://docs.microsoft.com/de-de/sql/t-sql/language-reference)) has some unique filters. Some queries would have to be rewritten for other backends.
## Unique Item Ids
Any resource maintained by the server at this time is referred to by a unique Id, which is a sequence of 64 bits (represented by an array of 8 bytes). This Id can be spotted in the Clients user interface at various locations, formatted as a hexadecimal byte array in brackets (example `[90105aaa8e3fb656]`). This scheme was chosen for being just long enough to make collisions mathematically very unlikely, yet remain easily equatable and identifiable by a human reader. At this time, Ids are generated by C#'s default random number generator. The [limits article](./limits.md#inconsistent-data) has some further notes on the consequences of the id scheme chosen.
## File Upload
See dedicated [file upload notes file](./fileupload.md)
# Client <-> Server communication
All types used in Client <-> Server communication are defined in the Shared library package.
## REST Api
All data flows where the client requests, manipulates or removes a server-side object is implemented via a REST Api.
The Api can be explored via swagger (linked from the index page). Please be aware that swagger does not understand custom Json converters, ItemIds in particular.
### Common Responses
* `200 Ok` Endpoint executed as expected
* `400 BadRequest` is returned whenever an endpoint is invoked with malformed input data
* `403 Unauthorized` is returned whenever an endpoint is invoked without necessary authorization
* `404 Notfound` is returned in any of these cases:
    * The endpoint does not exist
    * The requested resource does not exist
    * The authorized user cannot access the requested resource (same response as if resource does not exist to prevent automated spam of requests to attempt finding valid ids)
* `415 Unsupported Media Type` is returned whenever a file upload endpoint is invoked with incompatible media type
* `500 Internal Server Error` is returned whenever a server internal data manipulation fails (despite input data passing validation)
* `503 Service Unavailable` is returned when a server endpoint is invoked which was disabled (usually due to missing environment variables containing connection strings etc.)
### Endpoint Procedures
The order of operations in endpoint implementations always follows the same principles:
1. Check authentication (cheap)
1. Validate input (very cheap)
1. Validate resource access (expensive)
1. Manipulate data (very expensive)
1. Return a result

If any of the above fail the implementation immediately quits execution of the endpoint and returns an appropriate code. This approach minimizes area of attack and defers more expensive tasks as long as possible.
## SignalR
See dedicated [SignalR notes file](./signalr.md)